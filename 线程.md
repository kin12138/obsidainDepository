# 1. 概述
## 1.1 线程起源
由于进程都有自己独立的地址空间，系统每次切换资源时，内存中的数据段、代码段都需要被切换，时间和空间消耗都很大；此外操作系统允许多个进程并行执行，但是进程较为庞大，进程所占用的内存空间也相当大。
[[进程.canvas]]
进程由线程集和资源集组成。一个线程的实体包括程序、数据、TCB（Thread Control Block）、以及少量必不可少、用于保证线程独立运行的资源。

线程与进程最大的区别就是：**线程PCB中指向内存资源的三级页表相同，而进程PCB中指向内存资源的三级页表不同。**多个进程PCB中的三级页表指向的内存资源不同，所以即便不同进程使用相同的虚拟地址也不会产生冲突；但是一个进程空间中的多个线程TCB中的页目录指针指向相同的页目录、页目录对应相同的页表，最终页表又对应磁盘上相同的物理地址，也就是说，多个线程的虚拟地址会被映射到物理磁盘的同一段地址。

由于同一进程内的多个线程共享虚拟内存空间，也就共享相同的页目录、相同的页表、相同的物理存储空间，因此线程间很多数据是共享的。也正是因为这个原因，当多个线程需要同时对其中的数据进行访问时，就会产生竞争，导致读写错误。

当使用`fork()`创建一个新进程后，若其中有个进程要对`fork()`前的数据进行修改，进程中会根据“写时复用”原则，先复制一份该数据到子进程的地址空间，再修改数据。因此，**即使是全局变量，在进程间也不共享。**

但是因为线程间的地址空间共享，一个线程对全局区的数据做了修改，之后其他线程访问此数据都访问的是修改后的数据。

# 2. 线程操作
+ **创建线程：**`int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)` 线程创建成功返回`0`， 创建失败返回`errno`，由于`errno`很容易被修改，所以一般使用自定义变量接收`errno`，再调用`strerror()`将获取的错误码转换成错误信息，再打印出来。函数中包含4个参数：
 + 参数thread表示待创建线程的线程id指针，这是传出参数，若需要对该线程进行操作，需要一个pthread_t类型的变量来获取该参数
 + 参数attr用来设置待创建线程的属性，通常传入null，表示使用线程的默认属性
 + 参数start_routine是一个函数指针，指向一个参数为void，返回值也是void\*的函数，该函数为待创建线程的执行函数，线程创建成功后会执行该函数中的代码
 + 参数arg为要传给start_routine函数的参数
+ **退出线程：**`void pthread_exit(void *retval)`，参数retval是线程的退出状态。一般来说，`return`用于退出函数，若在线程中使用`return`退出线程，其效果也一样，`exit()`用于退出进程，若在线程中使用它，则会将线程所在进程一同退出。
+ **线程终止：**`int pthread_cancel(pthread_t thread)`，参数`thread`是线程id，如果成功终止线程，返回`0`，如果失败返回`errno`。此函数终止线程的退出值为`PTHREAD_CANCELED`，该宏定义在头文件`pthread.h`中，值为-1。
+ **线程挂起：**`int pthread_join(pthead_t thread, void **retval);`调用该函数的线程会使自己挂起，并等待指定线程thread结束。注意：该线程中指定的线程必须与当前调用此函数的线程处于同一进程中，且多个线程不能同时挂起等待同一个进程，否则`pthread_join()`会返回错误。pthread_join()调用成功返回0，失败返回errno。参数thread表示被等待的线程id，参数retval用于接收thread线程执行函数的返回值指针，该指针的值与thread线程的终止方式有关：
 + thread线程通过return返回，retval所指的存储单元中存放thread线程函数的返回值。
 + thread线程被其他线程通过系统调用pthread_cancel()终止，retval所指存储单元中存放的是常量PTHREAD_CANCELED
 + thread线程自己调用pthread_exit()退出线程，retval所指存储单元中存放pthread_exit()中的参数ret_val
 + 若等待thread的线程不关心它的终止状态，可以将retval的值设为null。
+ **线程分离：**在线程自己终止之后，其他函数调用pthread_join()函数获取其状态之前，该线程一直保持终止状态，类似进程中的僵尸态，虽然处于僵尸态的线程中大部分资源都已经被释放，但是还是有少量残留，进程会保持僵尸态一直存在于系统中，因此内核会认定进程依然存在，导致僵尸进程无法回收。线程机制中提供pthread_detach()函数弥补此不足。`int pthread_detach(pthread_t thread);`参数thread是待分离的线程id，若函数调用成功返回0，失败返回errno。
 + 若线程处于分离状态(detached)，我们就不能使用pthread_join()函数来终止线程，此时，因为detached状态的线程在后台运行结束会自动释放资源 ，包括残留的资源，从而使子线程自动回收。

# 3.线程属性
使用pthread_create()创建线程时，第二个参数为线程属性，该参数是一个pthread_attr_t类型的结构体，在调用pthread_create()前应该先初始化该结构体。pthread_attr_t的定义如下：
```c++
typedef struct{
 int etachstate;//线程的分离状态
 int schedpolicy;//线程调度策略
 struct sched_param schedparam;//线程的调度参数
 int inheritsched;//线程的继承性
 int scope;//线程的作用域
 size_t guardsize;//线程栈末尾的警戒缓冲区大小
 int stackaddr_set;//线程栈的设置
 void * stackaddr;//线程栈的位置
 size_t stacksize;//线程栈的大小
} pthread_attr_t;
```

## 3.1 初始化函数pthread_attr_init()
`pthread_attr_init(pthread_attr_t *attr);`
调用此函数，线程属性会被设置为默认值，默认情况下，线程处于非绑定、非分离状态，并与父进程共享优先级。

## 3.2 销毁属性资源pthread_attr_destory()
`pthread_attr_destory(pthread_attr_t *attr);`
此函数用于销毁线程的属性资源。

## 线程的调度策略
Linux下线程的调度策略分为三种：SCHED_OTHER、SCHED_FIFO、SCHED_RR

# 4. 线程同步
## 4.1 互斥锁
实现互斥锁，系统会为共享资源添加一个标记，称为互斥锁，防止线程同一时刻访问相同的公共资源。
互斥锁可以保证线程具有：
1. 原子性：如果在一个线程中设置了互斥锁，那么在加锁和解锁之间的操作被锁定为一个原子操作，这些操作要么都完成，要么一个也不执行。
2. 唯一性：如果一个线程锁定了一个互斥锁，在解除锁定之前没有任何线程可以锁定这个互斥量
3. 非繁忙等待：当一个线程锁定了一个互斥锁，之后第二个线程试图锁定该互斥锁，则第二个线程会被挂起，直到第一个线程主动解除该互斥锁，第二个线程才被唤醒，同时锁定该互斥锁。

使用互斥锁主要包含四步：初始化互斥锁、加锁、解锁、销毁互斥锁，Linux中提供的互斥锁的调用：`pthread_mutex_init();` `pthread_mutex_lock();` `pthread_mutex_unlock();` `pthread_mutex_destory();` 

### 4.1.1 pthread_mutex_init()接口：
声明：`int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);` 
+ 第一个参数**mutex**是一个pthread_mutex_t类型的传出参数，mutex只能有两种取值：0，1，因此加锁操作可视为mutex-1;解锁操作可视为mutex+1; **restrict是关键字**，用于限制指针，功能是告诉编译器，所有修改该指针指向内存中内容的操作，都只能通过本指针完成。
+ 第二个参数attr是一个传入参数，代表互斥量的属性，通常传入null，表示默认属性

函数调用成功返回0，失败返回errno，errno的常见取值为：EAGAIN、EDEADLK。EAGAIN表示超出互斥锁递归锁定的最大次数，因此无法获取该锁；EDEADLK表示当前线程已有互斥锁，二次加锁失败。

互斥锁也可以使用宏进行初始化：
`pthead_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;`

### 4.1.2 pthread_mutex_lock()
声明：`int pthread_mutex_lock(pthread_mutex_t *mutex);`
mutex参数表示待锁定的互斥量，若函数调用成功返回0，失败返回errno。
 *如果需要使用的互斥锁正在被使用，调用pthread_mutex_lock()的线程会进入阻塞。*
Linux中还提供了pthread_mutex_trylock()函数，功能是尝试加锁，如果锁正在被使用，不阻塞等待，直接返回并返回错误号。
声明：`int pthread_mutex_trylock(pthread_mutex_t *mutex);`
若函数调用成功返回0，失败返回errno。常见errno为：EBUSY, EAGAIN。
+ EBUSY: 参数mutex指向的互斥锁已锁定
+ EAGAIN: 超过互斥锁递归锁定的最大次数

### 4.1.3 pthread_mutex_unlock()
声明：`int pthread_mutex_unlock(pthread_mutex_t *mutex);`
同上，成功返回0，失败返回errno

### 4.1.4 pthread_mutex_destroy()
声明：`int pthread_mutex_destroy(pthread_mutex_t *mutex);`
同上，成功返回0，失败返回errno

## 4.2 条件变量
条件变量一般和互斥锁搭配使用，在线程访问共享资源时，先绑定一个互斥锁，然后检查条件变量。若条件变量满足，线程继续，并在资源访问完成之后解锁；若条件变量不满足，线程将解锁，进入阻塞状态，直到条件变量满足。
一般条件变量由其他非阻塞线程改变，当条件变量被改变至满足某一阻塞态线程，这些线程会再次争夺互斥锁，对条件变量进行测试。
一般条件变量的使用有四步：
1. 初始化条件变量
2. 等待条件变量满足
3. 唤醒阻塞线程
4. 释放条件变量
linux提供的与条件变量有关的调用：

### 4.2.1 pthread_cond_init()
声明：`int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);`
参数cond代表条件变量，是一个指向pthread_cond_t类型的指针，参数attr代表条件变量的属性，通常设为null，代表使用默认属性初始化条件变量，默认值为：PTHREAD_PROCESS_PRIVATE，表示当前进程中的线程共用此条件变量；attr也可以设置为PTHREAD_PROCESS_SHARED，表示多个进程间的线程共用此条件变量。

函数调用成功返回0， 失败返回-1，并设置errno。

除了函数调用初始化条件变量，也可以使用静态方法初始化：
`pthread_cond_t cond = PTHREAD_COND_INITIALIZER;`
此方法与函数初始化中attr设为null等效，但是不进行错误检查。

### 4.2.2 pthread_cond_wait()
阻塞等待条件变量，声明：`int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);`
参数cond是条件变量，mutex是与当前线程绑定的互斥锁。函数调用成功返回0，失败返回-1，并设置errno。

此函数的工作机制：
1. 阻塞等待，直到条件变量cond满足;
2. 解除已绑定的互斥锁（类似已于pthread_mutex_unlock()）;
3. 当前线程被唤醒，pthread_cond_wait()函数返回，pthread_cond_wait()函数同时会解除线程阻塞，并使线程重新申请绑定互斥锁。
前两条是原子操作，最后一条中，解除线程阻塞和绑定互斥锁并不是原子操作，当线程解除阻塞之后，此线程将和其他线程共同争夺互斥锁。

条件变量机制控制逻辑流程：[[条件变量控制机制.canvas]]

还有个函数也可以阻塞线程等待条件变量：pthread_cond_timedwait()，不同的是，这个函数可以指定阻塞时长，若超时，函数就会返回。

声明：`int pthread_cond_timedwait(pthread_cond_t *restrcit cond, pthread_mutex_t *mutex, const struct timespec *restrict abstime);`

参数cond代表条件变量，mutex代表互斥量，abstime代表绝对时间，用于设置等待时长，该参数是传入参数，本质是一个struct timespace类型的结构体指针，该结构体定义如下：
```c++
struct timespec{
 time_t tv_sec;//秒
 long tc_nsec;//纳秒
}
```

### 4.2.3 pthread_cond_signal()
pthread_cond_signal()函数会在条件变量满足之后，以信号的形式唤醒阻塞在该条件变量的线程。处于阻塞状态下的线程的唤醒顺序由调度策略来决定。

声明：`int pthread_cond_signal(pthread_cond_t *cond);`

### 4.2.4 pthread_cond_broadcast()
pthread_cond_broadcast()函数同样唤醒阻塞在指定条件变量的线程，不同的是，该函数以广播的形式，**唤醒在该条件变量上的所有线程**

声明：`int pthread_cond_broadcast(pthread_cond_t *cond);`

## 4.3 信号量
在互斥锁中，互斥锁的值只有两个，初值为1，加锁-1，解锁+1，具有唯一、非空闲等待的特性，但是也正因为这个特性，导致线程由并发执行变为串行，削弱了线程的并发性。**多线程编程中使用信号量机制解决了这一问题**，线程中的信号量是互斥锁的升级版，初值不再是1，而是N。

使用信号量进行线程同步时，线程在访问共享资源时会根据操作类型执行P/V操作：*若有线程申请访问共享资源，系统执行P操作使共享资源计数-1；若由线程释放共享资源，系统会执行V操作，使共享资源计数+1；*

相对互斥锁来说，信号量保证了线程的并发性，既能保证同步，防止数据混乱，又能避免影响线程并发性。

信号量的使用分为四步：
1. 初始化信号量
2. 阻塞等待信号量
3. 唤醒阻塞线程
4. 释放信号量

Linux中针对信号量操作的函数：
### 4.3.1 sem_init()
声明：`int sem_init(sem_t *sem， int pshared, unsigned int value);`

其中参数sem是指向信号量变量的指针。参数pshared用于控制信号量的作用范围，其取值通常为0或非0，当pshared设为0，信号量放入进程中所有线程可见的地址，可以被本进程中的所有线程共享；当pshared被设为非0时，信号量被放入共享内存区域，由所有进程共享。参数value用于设置信号量sem的初值。

函数执行成功返回0，失败返回-1，并设置errno。

### 4.3.2 sem_wait()
声明：`int sem_wait(sem_t *sem);`

参数sem指向信号量变量；sem_wait()函数对应P操作，若调用成功，会使信号量sem的值-1，并返回0，否则返回-1，并设置errno

sem_wait()与pthread_mutex_lock()类似，当sem为0时，即共享资源耗尽，再有线程访问共享资源，则会进入阻塞状态，直到有其他线程释放资源为止。

若并不希望线程因为资源不足而进入阻塞状态，可以使用sem_trywait()函数，尝试去为线程申请资源，若申请不成功就立即返回，与pthread_mutex_trywait()类似。

### 4.3.3 sem_post()
声明：`int sem_post(sem_t *sem);`

sem_post()函数对应V操作，若调用成功，则会使信号量sem+1，并返回0，否则返回-1，并设置errno

### 4.3.4 sem_destroy()
信号量也是系统资源，使用结束后应主动回收
声明：`int sem_destroy(sem_t *sem);`

### 4.3.5 sem_getvalue()
声明：`int sem_getvalue(set_t *sem, int *sval);`

函数功能是：获取系统中当前信号量的值。参数sval是一个传出参数，用于接收信号量的值。

**当信号量的初值被设为1时，信号量与互斥锁功能相同，因此互斥锁也是信号量的一种。**